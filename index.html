<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>Vite les Mots ðŸŽ¯</title>
  <link rel="stylesheet" href="style.css">
  <link rel="manifest" href="manifest.json">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
</head>
<body>
  <header>ðŸŽ¯ Vite les Mots</header>

  <div id="installBar">
    <span>Install this app for a full-screen experience.</span>
    <button id="installBtn">Install</button>
  </div>
  <div id="iosTip">On iPhone, tap the Share icon, then "Add to Home Screen" to install.</div>

  <div id="controls">
    <div class="row">
      <input id="playerName" placeholder="Enter your name">
      <select id="category"></select>
    </div>
    <div class="row">
      <div>
        <label><input type="radio" name="mode" value="EN2FR" checked> English â†’ French</label>
        <label><input type="radio" name="mode" value="FR2EN"> French â†’ English</label>
        <label><input type="radio" name="mode" value="EITHER"> Either direction</label>
        <div class="small-muted" id="dirHint"></div>
      </div>
      <button id="startBtn">Start Game</button>
    </div>
    <div class="row">
      <div>
        <label>Refill:</label>
        <select id="refillMode">
          <option value="instant" selected>Instant</option>
          <option value="delayed">Delayed</option>
          <option value="batch">Batch after clear</option>
        </select>
      </div>
      <div>
        <label>Delay (ms):</label>
        <input type="number" id="delayMs" value="600" min="0" step="100">
      </div>
    </div>
  </div>

  <div id="game-info">
    <span id="timer">Time: 60</span> | <span id="score">Score: 0</span>
  </div>

  <div id="mixed-grid" style="display:none;"></div>
  <div id="two-col" style="display:none;">
    <div class="col" id="from-col"></div>
    <div class="col" id="to-col"></div>
  </div>

  <div id="modal">
    <div id="modal-content">
      <h2>Game Over!</h2>
      <p id="final-score"></p>
      <div id="scoreboard"></div>
      <button id="closeBtn" type="button">Close</button>
    </div>
  </div>

  <script src="vocab.js"></script>
  <script>
    const ROUND_DURATION = 60;
    const INITIAL_PAIRS = 5;
    const ROUND_POOL_SIZE = 300;
    const AVOID_ACTIVE_DUPES = true;

    let cards = [];
    let leftCards = [];
    let rightCards = [];
    let activeKeys = new Set();
    let selected = [];
    let score = 0;
    let timeLeft = ROUND_DURATION;
    let timerInterval;
    let gameActive = false;

    let sessionPool = [];
    let poolIndex = 0;
    let currentMode = 'EN2FR';
    let currentCategory = null;
    let refillMode = 'instant';
    let replacementDelay = 600;
    let batchQueue = [];

    let deferredPrompt = null;
    window.addEventListener('beforeinstallprompt', (e) => {
      e.preventDefault();
      deferredPrompt = e;
      document.getElementById('installBar').style.display = 'block';
    });
    document.getElementById('installBtn').addEventListener('click', async () => {
      if (!deferredPrompt) return;
      deferredPrompt.prompt();
      await deferredPrompt.userChoice;
      deferredPrompt = null;
      document.getElementById('installBar').style.display = 'none';
    });
    const isIOS = /iphone|ipad|ipod/i.test(navigator.userAgent);
    const isInStandalone = window.matchMedia('(display-mode: standalone)').matches || window.navigator.standalone;
    if (isIOS && !isInStandalone) { document.getElementById('iosTip').style.display = 'block'; }

    if ('serviceWorker' in navigator) { navigator.serviceWorker.register('service-worker.js'); }

    window.addEventListener('load', () => {
      const catSel = document.getElementById('category');
      const order = [
        "Verbs (with conjugations)",
        "Nouns: Around Town",
        "Nouns: At Home",
        "Nouns: Directions",
        "Nouns: Food",
        "Nouns: Animals",
        "Nouns: Technology"
      ];
      const cats = getCategories();
      const finalCats = order.filter(c => cats.includes(c));
      finalCats.forEach(c => { const opt = document.createElement('option'); opt.value = c; opt.textContent = c; catSel.appendChild(opt); });
      if (finalCats.length) catSel.value = finalCats[0];

      document.querySelectorAll('input[name="mode"]').forEach(r => r.addEventListener('change', updateDirHint));
      document.getElementById('refillMode').addEventListener('change', e => refillMode = e.target.value);
      document.getElementById('delayMs').addEventListener('change', e => replacementDelay = Math.max(0, parseInt(e.target.value || '0', 10)));
      document.getElementById('startBtn').addEventListener('click', startGame);

      document.getElementById('closeBtn').addEventListener('click', closeModal, { passive: true });
      document.getElementById('closeBtn').addEventListener('touchend', closeModal, { passive: true });
      document.getElementById('modal').addEventListener('click', (e) => { if (e.target.id === 'modal') closeModal(); });

      updateDirHint();
    });

    function updateDirHint() {
      const mode = document.querySelector('input[name="mode"]:checked').value;
      const hint = document.getElementById('dirHint');
      if (mode === 'EN2FR') hint.textContent = 'Left column: English, Right column: FranÃ§ais';
      else if (mode === 'FR2EN') hint.textContent = 'Left column: FranÃ§ais, Right column: English';
      else hint.textContent = 'Either direction: mixed grid';
    }

    function startGame() {
      const name = document.getElementById('playerName').value.trim();
      if (!name) { alert('Enter your name'); return; }
      const modeInput = document.querySelector('input[name="mode"]:checked');
      currentMode = modeInput ? modeInput.value : 'EN2FR';
      currentCategory = document.getElementById('category').value;
      refillMode = document.getElementById('refillMode').value;
      replacementDelay = Math.max(0, parseInt(document.getElementById('delayMs').value || '0', 10));
      batchQueue = [];

      score = 0; timeLeft = ROUND_DURATION; gameActive = true;
      document.getElementById('score').innerText = 'Score: 0';
      document.getElementById('timer').innerText = 'Time: ' + ROUND_DURATION;
      selected = [];
      initSessionPool();
      clearInterval(timerInterval);
      timerInterval = setInterval(() => {
        timeLeft--;
        document.getElementById('timer').innerText = 'Time: ' + timeLeft;
        if (timeLeft <= 0) { clearInterval(timerInterval); endGame(); }
      }, 1000);

      document.getElementById('mixed-grid').style.display = (currentMode === 'EITHER') ? '' : 'none';
      document.getElementById('two-col').style.display = (currentMode === 'EITHER') ? 'none' : '';

      if (currentMode === 'EITHER') dealMixedBoard();
      else dealTwoColBoard();
    }

    function initSessionPool() {
      const base = getPairsForCategory(currentCategory);
      const clone = base.slice();
      shuffle(clone);
      const take = Math.min(clone.length, ROUND_POOL_SIZE);
      sessionPool = clone.slice(0, take);
      poolIndex = 0;
    }

    function nextPair() {
      if (sessionPool.length === 0) return null;
      for (let tries = 0; tries < sessionPool.length; tries++) {
        if (poolIndex >= sessionPool.length) { shuffle(sessionPool); poolIndex = 0; }
        const p = sessionPool[poolIndex++];
        const key = (p.english + '|' + p.french).toLowerCase();
        if (!AVOID_ACTIVE_DUPES || !activeKeys.has(key)) return p;
      }
      return sessionPool[Math.floor(Math.random() * sessionPool.length)];
    }

    // Mixed mode
    function dealMixedBoard() {
      cards = []; activeKeys.clear();
      for (let i = 0; i < INITIAL_PAIRS; i++) {
        const pair = nextPair(); if (!pair) break;
        const key = (pair.english + '|' + pair.french).toLowerCase();
        activeKeys.add(key);
        cards.push({ word: pair.english, match: pair.french, lang: 'en', key });
        cards.push({ word: pair.french, match: pair.english, lang: 'fr', key });
      }
      shuffle(cards); renderMixed();
    }
    function renderMixed() {
      const grid = document.getElementById('mixed-grid');
      grid.innerHTML = '';
      cards.forEach((card, idx) => {
        const el = document.createElement('div'); el.className = 'card'; el.innerText = card.word;
        el.onclick = () => selectCardMixed(el, card, idx); grid.appendChild(el);
      });
    }
    function selectCardMixed(element, card, idx) {
      if (!gameActive) return;
      if (selected.some(s => s.idx === idx)) return;
      selected.push({ element, card, idx });
      if (selected.length === 2) {
        const [a, b] = selected;
        const ok = a.card.match === b.card.word && a.card.key === b.card.key;
        if (ok) {
          a.element.classList.add('correct'); b.element.classList.add('correct'); score++; document.getElementById('score').innerText = 'Score: ' + score;
          if (refillMode === 'batch') {
            a.element.style.visibility = 'hidden'; b.element.style.visibility = 'hidden';
            batchQueue.push({ i1: a.idx, i2: b.idx, key: a.card.key });
            if (batchQueue.length === INITIAL_PAIRS) refillBatchMixed();
            selected = []; return;
          }
          setTimeout(() => { replacePairMixedRandomSlots(a.idx, b.idx, a.card.key); selected = []; }, replacementDelay);
        } else {
          a.element.classList.add('incorrect'); b.element.classList.add('incorrect');
          setTimeout(() => { a.element.classList.remove('incorrect'); b.element.classList.remove('incorrect'); selected = []; }, 360);
        }
      }
    }
    function replacePairMixedRandomSlots(i1, i2, oldKey) {
      activeKeys.delete(oldKey);
      const pair = nextPair(); if (!pair) return;
      const key = (pair.english + '|' + pair.french).toLowerCase(); activeKeys.add(key);
      const indices = [i1, i2].sort((a,b)=>b-a);
      indices.forEach(i => cards.splice(i,1));
      const newCards = [
        { word: pair.english, match: pair.french, lang: 'en', key },
        { word: pair.french, match: pair.english, lang: 'fr', key }
      ];
      const pos1 = Math.floor(Math.random() * (cards.length + 1));
      let pos2 = Math.floor(Math.random() * (cards.length + 1));
      if (pos2 === pos1) pos2 = (pos2 + 1) % (cards.length + 1);
      cards.splice(pos1, 0, newCards[0]);
      const adj = pos2 >= pos1 ? pos2 + 1 : pos2;
      cards.splice(adj, 0, newCards[1]);
      renderMixed();
    }
    function refillBatchMixed() { cards = []; activeKeys.clear(); batchQueue = []; dealMixedBoard(); }

    // Two-column modes
    function dealTwoColBoard() {
      leftCards = []; rightCards = []; activeKeys.clear();
      for (let i = 0; i < INITIAL_PAIRS; i++) {
        const pair = nextPair(); if (!pair) break;
        const key = (pair.english + '|' + pair.french).toLowerCase();
        activeKeys.add(key);
        if (currentMode === 'EN2FR') {
          leftCards.push({ word: pair.english, match: pair.french, lang: 'en', key, side: 'left' });
          rightCards.push({ word: pair.french, match: pair.english, lang: 'fr', key, side: 'right' });
        } else {
          leftCards.push({ word: pair.french, match: pair.english, lang: 'fr', key, side: 'left' });
          rightCards.push({ word: pair.english, match: pair.french, lang: 'en', key, side: 'right' });
        }
      }
      shuffle(leftCards); shuffle(rightCards); renderTwoCol();
    }
    function renderTwoCol() {
      const left = document.getElementById('from-col'); const right = document.getElementById('to-col');
      left.innerHTML = ''; right.innerHTML = '';
      leftCards.forEach((card, idx) => { const el = document.createElement('div'); el.className = 'card'; el.innerText = card.word;
        el.onclick = () => selectTwoCol(el, card, idx, 'left'); left.appendChild(el); });
      rightCards.forEach((card, idx) => { const el = document.createElement('div'); el.className = 'card'; el.innerText = card.word;
        el.onclick = () => selectTwoCol(el, card, idx, 'right'); right.appendChild(el); });
    }
    function selectTwoCol(element, card, idx, side) {
      if (!gameActive) return;
      selected.push({ element, card, idx, side });
      if (selected.length === 2) {
        const [a, b] = selected;
        const crossCols = a.side !== b.side;
        const match = a.card.key === b.card.key;
        const dirOk = (currentMode === 'EN2FR' && a.card.lang === 'en') || (currentMode === 'FR2EN' && a.card.lang === 'fr');
        if (crossCols && match && dirOk) {
          a.element.classList.add('correct'); b.element.classList.add('correct'); score++; document.getElementById('score').innerText = 'Score: ' + score;
          if (refillMode === 'batch') {
            a.element.style.visibility = 'hidden'; b.element.style.visibility = 'hidden';
            batchQueue.push({ a, b });
            if (batchQueue.length === INITIAL_PAIRS) refillBatchTwoCol();
            selected = []; return;
          }
          setTimeout(() => { replaceTwoColRandomSlots(a, b); selected = []; }, replacementDelay);
        } else {
          a.element.classList.add('incorrect'); b.element.classList.add('incorrect');
          setTimeout(() => { a.element.classList.remove('incorrect'); b.element.classList.remove('incorrect'); selected = []; }, 360);
        }
      }
    }
    function replaceTwoColRandomSlots(a, b) {
      const oldKey = a.card.key; activeKeys.delete(oldKey);
      const pair = nextPair(); if (!pair) return;
      const key = (pair.english + '|' + pair.french).toLowerCase(); activeKeys.add(key);
      leftCards.splice(a.idx, 1); rightCards.splice(b.idx, 1);
      let leftNew, rightNew;
      if (currentMode === 'EN2FR') {
        leftNew  = { word: pair.english, match: pair.french, lang: 'en', key, side: 'left' };
        rightNew = { word: pair.french, match: pair.english, lang: 'fr', key, side: 'right' };
      } else {
        leftNew  = { word: pair.french, match: pair.english, lang: 'fr', key, side: 'left' };
        rightNew = { word: pair.english, match: pair.french, lang: 'en', key, side: 'right' };
      }
      const li = Math.floor(Math.random() * (leftCards.length + 1));
      const ri = Math.floor(Math.random() * (rightCards.length + 1));
      leftCards.splice(li, 0, leftNew); rightCards.splice(ri, 0, rightNew);
      renderTwoCol();
    }
    function refillBatchTwoCol() { batchQueue = []; dealTwoColBoard(); }

    // End
    function endGame() {
      if (!gameActive) return;
      gameActive = false;
      const name = document.getElementById('playerName').value.trim();
      saveScore(name, score, currentCategory, currentMode);
      showLeaderboard();
      document.getElementById('final-score').innerText = 'Your score: ' + score;
      document.getElementById('modal').style.display = 'flex';
    }
    function saveScore(name, score, category, mode) {
      const scores = JSON.parse(localStorage.getItem('scores') || '[]');
      const modeLabel = mode === 'EN2FR' ? 'ENâ†’FR' : (mode === 'FR2EN' ? 'FRâ†’EN' : 'Either');
      scores.push({ name, score, date: new Date().toLocaleDateString(), category, mode: modeLabel });
      localStorage.setItem('scores', JSON.stringify(scores));
    }
    function showLeaderboard() {
      const scores = JSON.parse(localStorage.getItem('scores') || '[]');
      scores.sort((a,b) => b.score - a.score);
      let html = '<h3>Leaderboard</h3><table><tr><th>Name</th><th>Score</th><th>Category</th><th>Direction</th><th>Date</th></tr>';
      scores.slice(0,10).forEach(s => { html += `<tr><td>${s.name}</td><td>${s.score}</td><td>${s.category||''}</td><td>${s.mode||''}</td><td>${s.date}</td></tr>`; });
      html += '</table>';
      document.getElementById('scoreboard').innerHTML = html;
    }
    function closeModal() { document.getElementById('modal').style.display = 'none'; }
    function shuffle(array) { for (let i = array.length - 1; i > 0; i--) { const j = Math.floor(Math.random() * (i + 1)); [array[i], array[j]] = [array[j], array[i]]; } }
  </script>
</body>
</html>
